package csp;


import java.util.HashMap;
import java.util.HashSet;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Queue;
import java.util.Comparator;

public abstract class ConstraintSatisfactionProblem {
	private final static boolean mrvON = true;
	private final static boolean lcvON = true;
	private final static boolean macON = true;
	
	// used to store performance information about search runs.
	//  these should be updated during the process of searches

	// see methods later in this class to update these values
	protected int nodesExplored;
	protected int maxMemory;

	// protected List<Integer> assignment;
	protected Assignment assignment;
	protected Domain domain;
	protected Constraint constraint;

	protected abstract void assignmentInit();
	// protected abstract List<Integer> orderDomainValues(HashMap<Integer, HashSet<Integer>> domainMap, int var);
	// protected abstract int unassignedVar(Domain domain);
	// protected abstract boolean inference(Domain domain);
	// protected abstract boolean assignmentComplete();
	// protected abstract boolean valueConsistent(int var, int value);

		// @Override
	protected List<Integer> orderDomainValues(Assignment assignment, Domain domain, int var){// seems that there need to be inference
		// or just use a int list in map
		// reorder by lcv
		List<Integer> ret = new ArrayList<Integer>(domain.map.get(new Integer(var)));
		if (lcvON) {// sort the list
			Collections.sort(ret, new Comparator<Integer>(){
			public int compare(Integer v1, Integer v2) {
		    	//descending order
		      	return constraint.valueFlexibility(assignment, domain, var, v1.intValue()) <= 
		      		constraint.valueFlexibility(assignment, domain, var, v2.intValue()) ? 1 : -1;
		    }
			});
		}
		return ret;
	}

	// @Override
	protected int unassignedVar(Assignment assignment, Domain domain){
		// order on index
		// add mrv
		int ret = -1;
		if (mrvON) {
			if (assignment.assigned == 0) {// initial assignment
				ret = constraint.degreeHeuristic(assignment);	
			} else {
				ret = domain.mrv().intValue();
			}
		} else {
			ret = assignment.assigned;
		}

		return ret;
	}

	// @Override
	protected boolean inference(Assignment assignment, Domain domain, int var){// mac
		return macON ? constraint.mac3(assignment, domain, var) : !macON;
	}

	// @Override
	protected boolean assignmentComplete(){
		return assignment.allAssigned();// && constraint.isSatisfied(assignment);
	}


	// @Override
	protected boolean valueConsistent(int var, int value){// can integrate this in orderDomainValues
		return constraint.isSatisfied(assignment, var, value);
	}


	public Assignment basicBacktrackingSearch() {
		resetStats(); 

		return backtrack(assignment, domain);
	}

	// recursive memoizing dfs. Private, because it has the extra
	// parameters needed for recursion.  
	private Assignment backtrack(Assignment assignment, Domain dom) {
		Assignment result = null;

		if (this.assignmentComplete()) {// assignment is complete
			// System.out.println("test");
			result = assignment;
		} else {
			int var = this.unassignedVar(assignment, dom); // next variable, or generated by the problem
			for (Integer valueObj: this.orderDomainValues(assignment, dom, var)) {
				int value = valueObj.intValue();
				if (valueConsistent(var, value)) {// value is consistent with assignment
					assignment.assign(var, value);

					// inference goes here, update domain copy
					Domain tempDom = new Domain(dom);
					if (inference(assignment, tempDom, var)) {// update domain and 
						
						result = backtrack(assignment, tempDom);
						if (result != null) {
							break;
						}
					}

					assignment.unassign(var);

				}
			}
		}

		return result;
	}


	protected void resetStats() {
		nodesExplored = 0;
		maxMemory = 0;
	}
	
	protected void printStats() {
		System.out.println("Nodes explored during last search:  " + nodesExplored);
		System.out.println("Maximum memory usage during last search " + maxMemory);
	}
	
	protected void updateMemory(int currentMemory) {
		maxMemory = Math.max(currentMemory, maxMemory);
	}
	
	protected void incrementNodeCount() {
		nodesExplored++;
	}

	public class Assignment{
		protected List<Integer> unassigned;

		protected int[] assignment;
		protected int varCount;
		protected int assigned;
		public Assignment(int count){
			this.varCount = count;
			assignment = new int[varCount];
			this.assigned = 0;
			unassigned = new ArrayList<Integer>(varCount);
			for (int i = 0; i < varCount; ++i) {
				assignment[i] = -1;
				unassigned.add(new Integer(i));
			}
		}

		public Assignment(Assignment ass){
			this.varCount = ass.varCount;
			this.assigned = ass.assigned;
			System.arraycopy(ass.assignment, 0, this.assignment, 0, varCount);
			this.unassigned = new ArrayList<Integer>(ass.unassigned);
		}

		public void assign(int var, int val){
			assignment[var] = val;
			assigned++;
			unassigned.remove(new Integer(var));
		}

		public void unassign(int var){
			assignment[var] = -1;
			assigned--;
			unassigned.add(new Integer(var));
		}

		public boolean isAssigned(int var){
			return assignment[var] != -1;
		}

		public boolean allAssigned(){
			return assigned == varCount;
		}

		public int assignmentAt(int var){
			return assignment[var];
		}

		public void print(){
			for (int val: assignment) {
				System.out.print(val + " ");
			}
			System.out.print("\n");
		}

	}


	public class Domain{
		protected HashMap<Integer, HashSet<Integer>> map;

		public Domain(HashMap<Integer, HashSet<Integer>> domainMap){
			this.map = domainMap;
		}

		public Domain(Domain dom){
			this.map = new HashMap<Integer, HashSet<Integer>>();
			for (Integer key: dom.map.keySet()) {
				this.map.put(key, new HashSet<Integer>(dom.map.get(key)));
			}
		}

		public Integer mrv(){
			return Collections.min(assignment.unassigned, new Comparator<Integer>(){
			public int compare(Integer v1, Integer v2) {
		    	//ascending order
		      	return map.get(v1).size() >= map.get(v2).size() ? 1 : -1;
		    }
			});
		}

	}
}
